(function () {
  'use strict';

  var d = document;

  var defineProperty = Object.defineProperty;

  /* eslint-disable no-useless-escape */

  var STRING_replace = 'replace';

  var redact = function (url) {

    url = url

      /* eslint-disable no-unexpected-multiline */

      // double encoded
      [STRING_replace](/%2523access_token%253D.*?%2526/gmi, '%2526')
      // single encoded
      [STRING_replace](/%23access_token%3D.*?%26/gmi, '%26')
      // not encoded
      [STRING_replace](/#access_token=.*?&/gmi, '&')

      // remove information query values
      [STRING_replace](/information=[^\&]+/, '')

      // remove puser query values
      [STRING_replace](/puser=[^\&]+/, '')

      // remove fnuser query values
      [STRING_replace](/fnuser=[^\&]+/, '')

      // remove lnuser query values
      [STRING_replace](/lnuser=[^\&]+/, '');

    /* eslint-enable no-unexpected-multiline */

    return url;

  };

  try {
    var
      referrer = 'referrer',
      r = d[referrer],
      redacted = redact(r);

    // if something was removed and now they are not the same, redefine referrer
    // NOTE: We don't want to ALWAYS redefine referrer.  That might have some
    // side-effects we weren't expecting or possibly performance implications.
    // So do this ONLY when necessary.
    if (redacted !== r) {
      defineProperty(d, referrer, {
        configurable: true,
        value: redacted
      });
    }

  } catch (e) {
    // console.error(e);
  }

  var w = window;

  var consoleLog = w.console.log;

  function throwError (message) {
    throw Error(message);
  }

  var __satelliteEmbedCode = w.__satelliteEmbedCode;

  var marketingtech = w.marketingtech;

  /* eslint-env browser */

  var digitalData;
  var DigitalData;
  var digitalDataString = 'digitalData';
  var digitalDataStringPlusPeriod = digitalDataString + '.';
  var objectString = 'object';
  var arrayString = 'array';
  var functionString = 'function';
  var subObjectNot = 'sub-object not ';
  var subObjectNotObject = subObjectNot + objectString;
  var subObjectNotArray = subObjectNot + arrayString;
  var prototype;
  var _merge;
  var _flatten;
  var _collapse;
  var _recurse;
  var REGEX_PATH_ARRAY = /^(.+?)((?:\[(?:n|\d+)\])+?)$/;
  var REGEX_ARRAY_PART = /n|\d+/g;
  var isArray = Array.isArray;
  var getTypeOf;
  var hasOwnProp;
  var digitalDataId = 0;
  var debug = (
    marketingtech &&
    marketingtech.digitalData &&
    marketingtech.digitalData.debug
  );

// save space
  getTypeOf = function (value) {
    return typeof value;
  };
  hasOwnProp = function (obj, property) {
    return obj.hasOwnProperty(property);
  };

//------------------------------------------------------------------------------
// DigitalData Class constructor
//------------------------------------------------------------------------------
  DigitalData = function (data, pending) {
    var
      _this = this,

      path;

    // _id
    //
    // The id of the data layer for debugging purposes
    // we don't want this to be enumerable when copying
    defineProperty(_this, '_id', {
      // configurable: false, // false by default
      // enumerable: false, // false by default
      value: ++digitalDataId,
    });

    // debug logs
    if (debug) {
      consoleLog(_this._id + ': CREATED');
    }

    // _pending
    //
    // The list of pending promises that have not been resolved yet.
    // _this._pending = {};
    // we don't want this to be enumerable when copying
    defineProperty(_this, '_pending', {
      // configurable: false, // false by default
      // enumerable: false, // false by default
      value: {},
    });

    // _listeners
    //
    // The list of listener that need to be called when an event fires.
    // _this._listeners = {};
    // we don't want this to be enumerable when copying
    defineProperty(_this, '_listeners', {
      // configurable: false, // false by default
      // enumerable: false, // false by default
      value: {},
    });

    // if we were sent data to initialize
    if (data) {

      // set digitalData
      _this._set(digitalDataString, data);

    }

    // if we have pending values
    if (pending) {

      // loop through each of the pending promises
      for (path in pending) {
        if (!hasOwnProp(pending, path)) {
          continue;
        }

        // directly set them
        _this._set(path, pending[path]);
      }

    }

  };

// get the prototype of the class
  prototype = DigitalData.prototype;

// _merge
//
// This function will take two objects and merge them together.  If there are
// properties on both objects, they will be converted to an array and both
// values will become items in the array.
  prototype._merge = _merge = function (obj1, obj2, ignoreDuplicates, tab) {
    var
      property,
      value1,
      value2,
      type1,
      type2;

    tab = tab || '';

    // loop through obj2's properties
    for (property in obj2) {
      if (!hasOwnProp(obj2, property)) {
        continue;
      }

      // get the values
      value1 = obj1[property];
      value2 = obj2[property];

      // make sure the value we are merging isn't null or undefined
      if (
        value2 === undefined ||
        value2 === null
      ) {
        continue;
      }

      // console.log(tab, value1, value2);

      // if we don't have that property, just set value2 on obj1
      if (
        value1 === undefined ||
        value1 === null
      ) {
        obj1[property] = value2;

        // otherwise if we have that property
      } else {

        // get the types of both
        type1 = isArray(value1) ? arrayString : getTypeOf(value1);
        type2 = isArray(value2) ? arrayString : getTypeOf(value2);

        // if the value1 or value2 is an object
        if (
          type1 === objectString ||
          type2 === objectString
        ) {

          // make sure that both are object types
          if (type1 === type2) {

            // recursive merge the two values together and set it as property
            obj1[property] = _merge(value1, value2, ignoreDuplicates, tab + '  ');

            // otherwise just ignore the merge if they both aren't objects
          } else {
            // TODO: Determine if this is actually what we want
          }

          // otherwise we are dealing with arrays, numbers, booleans, or strings
        } else {

          // flag to ignore merging if we find duplicates
          if (!ignoreDuplicates) {

            // convert value1 to an array
            if (type1 !== arrayString) {
              value1 = [value1];
            }

            // both are arrays
            if (type2 === arrayString) {

              // concat the two arrays together
              value1 = value1.concat(value2);

              // the first is an array
            } else {

              // append the value2 to value1
              value1.push(value2);
            }

            // finally make sure to set the property
            obj1[property] = value1;

          }

        }

      }

    }

    return obj1;
  };

// _flatten
//
// This function will try to flatten the sub-objects down to a single object
// with properties with the names delimited
  prototype._flatten = _flatten =  function (obj, prefix, joinAndCollapse, filter) {
    var
      i, il,
      key,
      properties,
      property,
      value,

      flat = {},

      collapsed = {};

    // default to this
    obj = obj || this;

    // copy object so we don't modify the original
    obj = JSON.parse(JSON.stringify(obj));

    if (isArray(obj)) {
      properties = obj;
    } else {
      properties = Object.keys(obj);
    }

    // loop through each of the properties
    for (i = 0, il = properties.length; i < il; i++) {

      // get the property or index
      if (isArray(obj)) {
        property = i;
      } else {
        property = properties[i];
      }

      // change the key
      if (prefix) {
        if (isArray(obj)) {
          // key = prefix + '[' + property + ']';
          key = prefix + '.' + property + '';
        } else {
          key = prefix + '.' + property;
        }
      } else {
        key = property + '';
      }

      // get the value
      value = obj[property];

      // if the value is an object or array, recursively flatten
      if (
        getTypeOf(value) === objectString &&
        // make sure it is not null
        value !== null
      ) {

        // call flatten passing the new key
        flat = _merge(flat, _flatten(value, key, joinAndCollapse, filter), true);

        // otherwise, just save it as a value
      } else if (getTypeOf(value) !== functionString) {

        // if we were passed a filter
        if (filter) {

          // if it is is an object
          if (getTypeOf(filter) === objectString) {

            // if it is an array
            if (isArray(filter)) {

              // check in the array for the current path and if it is not there,
              // don't set value
              if (filter.indexOf(key) !== -1) {
                flat[key] = value;
              }

              // if it is an object
            } else {

              // check in the object for the current path and if it is either not
              // there or falsy, return and don't keep processing
              if (filter[key]) {
                flat[key] = value;
              }

            }

            // if it is a function
          } else if (getTypeOf(filter) === functionString) {

            // call the method and if it returns false for the current path, return
            // and don't keep processing
            if (
              filter(key)
            ) {
              flat[key] = value;
            }

            // for every other data type possibilities of filter, always set
            // everything
          } else {
            flat[key] = value;
          }

          // otherwise just set everything
        } else {
          flat[key] = value;
        }

      }
    }

    // do some special array stuff after this
    // if it isn't an array, just return
    if (!isArray(obj) || !joinAndCollapse) {
      return flat;
    }

    // NOTE: This block is not longer needed with filter
    //
    // // if it is is an object
    // if (getTypeOf(joinAndCollapse) === objectString) {

    //   // if it is an array
    //   if (isArray(joinAndCollapse)) {

    //     // check in the array for the current path and if it is not there,
    //     // return and don't keep processing
    //     if (joinAndCollapse.indexOf(prefix) === -1) {
    //       return flat;
    //     }

    //   // if it is an object
    //   } else {

    //     // check in the object for the current path and if it is either not
    //     // there or falsy, return and don't keep processing
    //     if (!joinAndCollapse[prefix]) {
    //       return flat;
    //     }

    //   }

    // // if it is a function
    // } else if (getTypeOf(joinAndCollapse) === functionString) {

    //   // call the method and if it returns false for the current path, return
    //   // and don't keep processing
    //   if (
    //     !joinAndCollapse(prefix)
    //   ) {
    //     return flat;
    //   }

    // }

    // special properties for Arrays to handle them easier
    for (i = 0, il = properties.length; i < il; i++) {

      // get the index
      property = i;

      // get the value
      value = obj[property];

      // collapse
      if (
        getTypeOf(value) === objectString
      ) {
        collapsed = _merge(collapsed, value);
      }

    }

    // change the key
    if (prefix) {
      key = prefix + '.' + '__collapsed';
    } else {
      key = '__collapsed';
    }

    // set it
    flat = _merge(
      flat,
      _flatten(collapsed, key, joinAndCollapse, filter),
      true
    );

    // collapse
    flat = _merge(
      flat,
      _flatten(
        _collapse(collapsed, '|', '|', '|'),
        key,
        joinAndCollapse,
        filter
      ),
      true
    );

    // change the key
    if (prefix) {
      key = prefix + '.' + '__joined';
    } else {
      key = '__joined';
    }

    // set
    flat = _merge(
      flat,
      _flatten(collapsed, key, joinAndCollapse, filter),
      true
    );

    // join
    flat = _merge(
      flat,
      _flatten(
        _collapse(collapsed, ','),
        key,
        joinAndCollapse,
        filter
      ),
      true
    );

    // collapsed
    // console.log(JSON.stringify(collapse(collapsed), null, '  '));

    return flat;
  };

// _collapse
//
// This function will take any array properties and will join them together
// into a string with a delimiter value and a start and end.
  prototype._collapse = _collapse = function(obj, delimiter, prefix, suffix) {
    var
      property,
      value,
      type,
      collapsed = {};

    // defaults
    delimiter = delimiter || ',';
    prefix = prefix || '';
    suffix = suffix || '';

    // loop through obj's properties
    for (property in obj) {
      if (!hasOwnProp(obj, property)) {
        continue;
      }

      // get the value
      value = obj[property];

      // get the type
      type = isArray(value) ? arrayString : getTypeOf(value);

      if (type === arrayString) {
        collapsed[property] = prefix + value.join(delimiter) + suffix;
      } else if (type === objectString) {
        collapsed[property] = _collapse(value, delimiter, prefix, suffix);
      } else {
        collapsed[property] = value;
      }

    }

    return collapsed;
  };

// _recurse
//
// This function will take an object or array and resurse over all of its
// properties/indexes as well as it's properties/indexes.
  prototype._recurse = _recurse = function(obj, path, beforeCallback, afterCallback) {
    var
      i, il,
      property,
      properties,
      childPath,
      value;

    // only recurse through objects or arrays
    if (
      // is undefined or null
      !obj ||
      // or is not an object
      getTypeOf(obj) !== objectString
    ) {
      return;
    }

    // determine the properties to iterate over
    if (isArray(obj)) {
      properties = obj;
    } else {
      properties = Object.keys(obj);
    }

    // loop through each of the properties
    for (i = 0, il = properties.length; i < il; i++) {

      // get the property or index
      if (isArray(obj)) {
        property = i;
        childPath = path + '[n]';
      } else {
        property = properties[i];
        childPath = path + '.' + property;
      }

      // get the value
      value = obj[property];

      // call the beforeCallback
      beforeCallback && beforeCallback({
        path: childPath,
        property: property,
        value: value,
      }, {
        path: path,
        value: obj,
      });

      // recurse
      if (
        // not null
        value &&
        // and is an object
        getTypeOf(value) === objectString
      ) {
        _recurse(value, childPath, beforeCallback, afterCallback);
      }

      // call the afterCallback
      afterCallback && afterCallback({
        path: childPath,
        property: property,
        value: value,
      }, {
        path: path,
        value: obj,
      });

    }

  };

// _get
//
// This function will retrieve whatever data is located at the given
// property name or path.
  prototype._get = function (path) {
    var
      _this = this,

      obj = _this,
      pathSplit,
      pathPiece,
      pathPiece2,
      arrayParts,

      i, il,
      j, jl,
      isLast,
      isLast2;

    if (debug) {
      consoleLog(_this._id + ': GET "' + path + '"');
    }

    //----------------------------------------------------------------------------
    // validation and normalization
    //----------------------------------------------------------------------------

    // if they are just asking for the whole digitalData object, send it here
    if (
      !path ||
      path === digitalDataString
    ) {
      return _this;
    }

    // if the path doesn't start with "digitalData.", add it
    if (path.indexOf(digitalDataString) !== 0) {
      path = digitalDataStringPlusPeriod + path;
    }

    //----------------------------------------------------------------------------
    // get the value
    //----------------------------------------------------------------------------

    // split the path
    pathSplit = path.split('.');

    // if the first property in the list is "digitalData",
    // remove it completely and discard it
    pathSplit.shift();

    // loop through each of the path segments through each
    // of the sub-objects
    for (i = 0, il = pathSplit.length; i < il; i++) {

      // determine if it is the last piece
      isLast = (i === (il - 1));

      // get the pathPiece
      pathPiece = pathSplit[i];

      // try to get the array parts
      arrayParts = pathPiece.match(REGEX_PATH_ARRAY);

      // if this is supposed to be an array
      if (arrayParts) {

        // get the array property
        pathPiece = arrayParts[1];

        // get the indexes
        arrayParts = arrayParts[2].match(REGEX_ARRAY_PART);

        // drop down into sub-array
        obj = obj[pathPiece];

        // make sure the sub-object is the right type, or just return undefined
        if (!isArray(obj)) {
          return;
        }

        // loop through and drop into each part
        for (j = 0, jl = arrayParts.length; j < jl; j++) {

          // determine if it is the last piece
          isLast2 = (j === (jl - 1));

          // get the array part
          pathPiece2 = arrayParts[j];

          // transform into index
          // if end of the array
          if (pathPiece2 === 'n') {
            pathPiece2 = obj.length - 1;

            // if an index
          } else {
            pathPiece2 = parseInt(pathPiece2);
          }

          // get at the index
          obj = obj[pathPiece2];

          // if it isn't the last one and it isn't an array, return at that point
          if (
            // it isn't the last one
            !isLast2 &&
            // it is not an array
            !isArray(obj)
          ) {
            return;
          }

        }

        // drop down into sub-object
      } else {
        obj = obj[pathPiece];
      }

      // if it isn't defined, return at that point
      if (
        // if it is falseish
        !obj ||
        // or if it is the last segment
        isLast
      ) {
        return obj;
      }

    }

  };

// _set
//
// This function will set the given value at the given path.
  prototype._set = function (path, value) {
    var
      _this = this,

      obj = _this,
      oldValue,
      promise,

      i, il,
      j, jl,
      property,
      isLast,
      isLast2,

      pathSplit,
      pathPiece,
      pathPiece2,
      arrayParts,

      eventNamePieces,
      events = [],
      eventName,

      _pending = _this._pending;

    if (debug) {
      consoleLog(_this._id + ': SET "' + path + '" ' + JSON.stringify(value));
    }

    //----------------------------------------------------------------------------
    // validation and normalization
    //----------------------------------------------------------------------------

    // if we don't have a path here, just exit
    if (!path) {
      path = digitalDataString;
    }

    // if the path doesn't start with "digitalData.", add it
    if (path.indexOf(digitalDataString) !== 0) {
      path = digitalDataStringPlusPeriod + path;
    }

    // if the path is the root and the value is the same as _this, then ignore it
    // because that would be incorrect to set the data layer to itself and would
    // have unintended consequences
    if (
      path === digitalDataString &&
      value === _this
    ) {
      return;
    }

    //----------------------------------------------------------------------------
    // handle promises
    //----------------------------------------------------------------------------

    // if the promise exists, delete it
    if (_pending[path]) {

      // cancel the promise
      // TODO: Make sure that we only cancel the value for only my data layer
      // not any other copy of the data layer that may have a reference here
      _pending[path].cancelled = true;

      // delete it, because if this is set, it means we over-wrote it and no
      // longer should propagate it when copied
      delete _pending[path];

    }

    // handle promises
    if (
      // value is not null
      value != null &&
      // it is either an object or a function
      (
        getTypeOf(value) === objectString ||
        getTypeOf(value) === functionString
      ) &&
      // and it has a property ".then" which is a function
      getTypeOf(value.then) === functionString
    ) {

      // when it is resolved, reset it
      promise = value

        .then(function (resolved) {

          // if it wasn't cancelled
          if (!promise.cancelled) {

            // set the value
            _this._set(path, resolved);

            // Note: We don't cancel or delete from the _pending list here
            // because this is handled automatically through the _this._set
            // functionality above.  Anytime anything is set with the same
            // path, the _pending promise is cancelled and deleted.

          }

          return resolved;

        }, function () {

          // TODO: How should we handle the error here?

          // if it wasn't cancelled
          if (!promise.cancelled) {

            // Note: we DO have to delete the pending promise from the list here
            // because it is possible that we may reach this point if no one
            // tried to set this same path (cancelled it) and the promise we
            // are waiting for threw an exception.

            // delete it from the pending list
            delete _pending[path];

          }

          // TODO: Not sure what we should return here

        });

      // cancelled
      promise.cancelled = false;

      // capture the promise
      _pending[path] = promise;

      // if there is an unresolved default
      if (hasOwnProp(value, 'unresolved')) {

        // point to the value
        oldValue = value;

        // trade out the value and continue
        value = value.unresolved;

        // delete it so we don't accidentally set it again
        delete oldValue.unresolved;

        // if we don't have a default unresolved value, immediately return
      } else {
        return;
      }

    }

    //--------------------------------------------------------------------------
    // set the value
    //--------------------------------------------------------------------------

    // if the path is root
    if (path === digitalDataString) {

      // if the value isn't an object type, just return
      if (getTypeOf(value) !== objectString) {
        return;
      }

      // recurse through and cancel any pending promises, and build an events
      // string that includes all of the objects in the data layer
      // _recurse(_this, digitalDataString, function (current, parent) {
      _recurse(_this, digitalDataString, function (current) {

        // if this is a pending promise, cancel it and delete it
        if (_pending[current.path]) {

          // cancel the promise
          // TODO: Make sure that we only cancel the value for only my data layer
          // not any other copy of the data layer that may have a reference here
          _pending[current.path].cancelled = true;

          // delete it, because if this is set, it means we over-wrote it and no
          // longer should propagate it when copied
          delete _pending[current.path];

        }

        // add it to the events list
        events.push(current.path);

        // delete the property
        // delete parent.value[current.property];

      });

      // loop through each high level property and delete them from the data
      // layer as long as they are not references to us or the same object that is
      // set on the data layer
      for (property in _this) {
        if (!hasOwnProp(value, property)) {
          continue;
        }

        // if the item is not set on the value and it also not a reference to the
        // same thing we are looking at, delete it
        if (
          value[property] &&
          value[property] !== _this[property]
        ) {
          delete _this[property];
        }
      }

      // loop through each of the properties in the value and set them on the
      // data layer
      for (property in value) {
        if (!hasOwnProp(value, property)) {
          continue;
        }

        // if we are setting a safe value, set it directly (not using internal
        // _set handler because we will trigger than event later)
        _this[property] = value[property];
      }

    } else {

      // split the path
      pathSplit = path.split('.');

      // if the first property in the list is "digitalData",
      // remove it completely and discard it
      pathSplit.shift();

      // loop through each of the path segments through each
      // of the sub-objects
      for (i = 0, il = pathSplit.length; i < il; i++) {

        // determine if it is the last piece
        isLast = (i === (il - 1));

        // get the pathPiece
        pathPiece = pathSplit[i];

        // try to get the array parts
        arrayParts = pathPiece.match(REGEX_PATH_ARRAY);

        // if this is supposed to be an array
        if (arrayParts) {

          // get the array property
          pathPiece = arrayParts[1];

          // get the indexes
          arrayParts = arrayParts[2].match(REGEX_ARRAY_PART);

          // drop down into sub-array, if the sub-array isn't defined yet, create it
          obj = obj[pathPiece] = obj[pathPiece] || [];

          // make sure the sub-object is the right type
          if (!isArray(obj)) {
            throwError(subObjectNotArray);
          }

          // loop through and drop into each part
          for (j = 0, jl = arrayParts.length; j < jl; j++) {

            // determine if it is the last piece
            isLast2 = (j === (jl - 1));

            // get the array part
            pathPiece2 = arrayParts[j];

            // transform into index
            // if end of the array
            if (pathPiece2 === 'n') {
              pathPiece2 = obj.length;

              // if an index
            } else {
              pathPiece2 = parseInt(pathPiece2);
            }

            // if it is the last segment of path
            if (isLast2) {

              // if it is the last array part
              if (isLast) {

                // set at the index
                obj[pathPiece2] = value;

                // otherwise we are at the end
              } else {

                // drop down into an object
                obj = obj[pathPiece2] = obj[pathPiece2] || {};

                if (getTypeOf(obj) !== objectString) {
                  throwError(subObjectNotObject);
                }

              }

              // otherwise we still need to drop down
            } else {

              // drop down into an array
              obj = obj[pathPiece2] = obj[pathPiece2] || [];

              if (!isArray(obj)) {
                throwError(subObjectNotArray);
              }

            }

          } // for each array part

          // object
        } else {

          // if it is the last segment
          if (isLast) {

            // set the value
            obj[pathPiece] = value;

            // otherwise a sub-object
          } else {

            // drop down into sub-object, if the sub-object isn't defined yet, create it
            obj = obj[pathPiece] = obj[pathPiece] || {};

            // make sure the sub-object is the right type
            if (getTypeOf(obj) !== objectString) {
              throwError(subObjectNotObject);
            }

          }

        } // else - object

      } // for each path part

    } // else - not root object


    //----------------------------------------------------------------------------
    // dispatch events
    //----------------------------------------------------------------------------

    // loop through and push a list of events on the events to call
    if (path === digitalDataString) {

      // push the current path
      events.push(path);

    } else {

      // split the path again
      pathSplit = path.split('.');

      // initialize eventNamePieces and events
      eventNamePieces = [];

      // build all the events we need to fire
      // example:
      // for "digitalData.page.pageInfo.pageName", we would build these events
      // - digitalData
      // - digitalData.page
      // - digitalData.page.pageInfo
      // - digitalData.page.pageInfo.pageName
      for (i = 0, il = pathSplit.length; i < il; i++) {

        // get the peice
        pathPiece = pathSplit[i];

        // replace any specific array indexes for generic "[n]"
        // try to get the array parts
        arrayParts = pathPiece.match(REGEX_PATH_ARRAY);

        // if this is supposed to be an array
        if (arrayParts) {

          // get the array property
          pathPiece = arrayParts[1];

          // get the indexes
          arrayParts = arrayParts[2].replace(REGEX_ARRAY_PART, 'n');

          // join them
          pathPiece = pathPiece + arrayParts;

        }

        // push it on
        eventNamePieces.push(pathPiece);
        events.push(eventNamePieces.join('.'));
      }

    }

    // recurse through the structure and add an event for every property in the
    // object or array if this is an object or array
    _recurse(value, path, function (current) {

      // if this is a pending promise, cancel it and delete it
      if (_pending[current.path]) {

        // cancel the promise
        // TODO: Make sure that we only cancel the value for only my data layer
        // not any other copy of the data layer that may have a reference here
        _pending[current.path].cancelled = true;

        // delete it, because if this is set, it means we over-wrote it and no
        // longer should propagate it when copied
        delete _pending[current.path];

      }

      // add it to the events list if it isn't already there
      if (events.indexOf(current.path) === -1) {
        events.push(current.path);
      }

    });

    // loop through backwards because we want to fire the most granular properties
    // first
    for (i = events.length - 1; i >= 0; i--) {

      // get eventName
      eventName = events[i];

      // trigger the event
      _this._trigger(eventName);

    }

  };

// _unset / _delete
//
// This function will unset the given path.
  prototype._unset = prototype._delete = function (path) {
    var
      _this = this;

    if (debug) {
      consoleLog(_this._id + ': DELETE "' + path + '"');
    }

    return _this._set(path, undefined);
  };

// _on
//
// The function for attaching a listener to an event.
  prototype._on = function (eventName, callback) {
    var
      _this = this,

      listeners;

    // if we don't have an eventName here, just exit
    if (eventName === '') {
      eventName = digitalDataString;
      // path is not blank string
    } else if (!eventName) {
      return false;
    }

    // if the eventName doesn't start with "digitalData.", add it
    if (eventName.indexOf(digitalDataString) !== 0) {
      eventName = digitalDataStringPlusPeriod + eventName;
    }

    // get the listeners for that eventName
    listeners = _this._listeners[eventName];

    // make sure the list exists for that key
    if (!listeners) {
      listeners = _this._listeners[eventName] = [];
    }

    // add it to the list
    listeners.push(callback);
  };

// _off
//
// The function for detaching the listener from an event.
  prototype._off = function(eventName, callback) {
    var
      _this = this,

      index,
      listeners;

    // if we don't have an eventName here, just exit
    if (eventName === '') {
      eventName = digitalDataString;
      // path is not blank string
    } else if (!eventName) {
      return false;
    }

    // if the eventName doesn't start with "digitalData.", add it
    if (eventName.indexOf(digitalDataString) !== 0) {
      eventName = digitalDataStringPlusPeriod + eventName;
    }

    // get the listeners for that eventName
    listeners = _this._listeners[eventName];

    // if we can't find that eventName, return false
    if (!listeners) {
      return false;
    }

    // find out where it is
    index = listeners.indexOf(callback);

    // if we found it, remove it
    if (index !== -1) {
      listeners.splice(index, 1);
      return true;
    } else {
      return false;
    }
  };

// _trigger
//
// triggering an event
  prototype._trigger = function (eventName) {
    var
      _this = this,

      i,
      il,
      callback,
      listeners;

    // if we don't have an eventName here, just exit
    if (eventName === '') {
      eventName = digitalDataString;
      // path is not blank string
    } else if (!eventName) {
      return false;
    }

    // if the eventName doesn't start with "digitalData.", add it
    if (eventName.indexOf(digitalDataString) !== 0) {
      eventName = digitalDataStringPlusPeriod + eventName;
    }

    // get the listeners for that eventName
    listeners = _this._listeners[eventName];

    // if we can't find that eventName, return false
    if (!listeners) {
      return false;
    }

    for (i = 0, il = listeners.length; i < il; i++) {

      // find the callback
      callback = listeners[i];

      if (!callback) {
        continue;
      }

      // try to call the callback, passing in the value of the current path
      try {
        callback(
          _this._get(eventName)
        );
      } catch (err) {
        // Don't throw here
      }

    }
  };

// _resolved
//
// Get a promise for when all of the _pending promises have been resolved.
  prototype._resolved = function () {
    var
      _this = this,

      path,
      promises = [],

      _peding = _this._pending;

    for (path in _peding) {
      if (!hasOwnProp(_peding, path)) {
        continue;
      }

      promises.push(_peding[path]);
    }

    return Promise.all(promises);
  };

// _snapshot
//
// Make a copy of the data layer at this point in time
  prototype._snapshot = prototype._copy = function () {
    var
      _this = this,

      copy;

    // make a copy of the data layer (excludes methods and private properties)
    copy = new DigitalData(
      JSON.parse(JSON.stringify(_this)),
      _this._pending
    );

    return copy;
  };


//------------------------------------------------------------------------------
// export the class
//------------------------------------------------------------------------------
  w.DigitalData = DigitalData;


//------------------------------------------------------------------------------
// create new digitalData instance
//------------------------------------------------------------------------------
  if (!__satelliteEmbedCode) {
    digitalData = new DigitalData();

    // if we already have digitalData set on the window, merge it into our object
    // then delete it from the window and rebuild it so that it gets defined
    // correctly
    if (w.digitalData) {

      // merge
      digitalData._set(digitalDataString, w.digitalData);

      // delete
      try {
        delete w.digitalData;
      } catch (e) {
        // TODO:
      }

    }

    // Note: we do this so that the digitalData methods can't be clobbered or
    // overwritten
    defineProperty(w, digitalDataString, {
      // configurable: false, // false by default
      enumerable: true,
      get: function () {
        return digitalData;
      },
      set: function (value) {

        // set the root path
        digitalData._set(digitalDataString, value);

      }
    });

  }

// export
  var digitalData$1 = digitalData;

  var head = d.getElementsByTagName('head')[0];

  var p = w.performance;

  var decode = decodeURIComponent;

//----------------------------------------------------------------------------
// readCookie function
//----------------------------------------------------------------------------
  function readCookie (name) {
    var
      cookies,
      i, il,
      keyValue,
      key;

    // get cookies
    cookies = d.cookie ? d.cookie.split('; ') : [];

    // loop through each cookie
    for (i = 0, il = cookies.length; i < il; i++) {

      // get the key value pair
      // keyValue = cookies[i].split('=');
      keyValue = cookies[i];

      // get the name
      // key = decodeURIComponent(keyValue[0]);
      key = decode(keyValue.substr(0, keyValue.indexOf('=')));

      if (key === name) {
        return decode(keyValue.substr(keyValue.indexOf('=') + 1));
      }
    }

  }

  var STYLE_ID = 'at-body-style';
  var targetGlobalSettingsString = 'targetGlobalSettings';
  var bodyHidingEnabledString = 'bodyHidingEnabled';
  var target;
  var targetGlobalSettings;
  var optanonConsentCookie = readCookie('OptanonConsent');
  var optanonChoice = readCookie('OptanonChoice');
  var style;
  var search = w.location.search;

// get ref to target
  target = (
    marketingtech &&
    marketingtech.adobe &&
    marketingtech.adobe.target
  );

// get ref to global settings
  targetGlobalSettings = w[targetGlobalSettingsString] = w[targetGlobalSettingsString] || {};

// check if it exists first
  style = d.getElementById(STYLE_ID);

//------------------------------------------------------------------------------
// hide body if necessary
//------------------------------------------------------------------------------
  if (
    // we aren't loading at.js synchronously (we are loading it synchronously)
    !__satelliteEmbedCode &&
    // they set a flag that they want to use target
    target &&
    // they haven't already diabled body hiding through the target flags
    (
      // we either can't find any target global settings
      !(bodyHidingEnabledString in targetGlobalSettings) ||
      // or we found it and body hiding is enabled
      targetGlobalSettings[bodyHidingEnabledString]
    ) &&
    // they have not set the flag to indicate that target should get disabled (so we can load Target)
    (
      // !searchContains('mboxDisable=1')
      search.indexOf('mboxDisable=1') === -1
    ) &&
    // the opt-out cookie is not present (so we can load Target)
    (
      d.cookie.indexOf('adobe_optout') === -1
    ) &&
    // onetrust says we are okay
    // check for explicit opt-out and negate that...meaning if the condition in
    // the parenthesis evals to false, then we are okay
    !(
      // They have explicitly made a choice
      optanonChoice &&
      // optanon cookie is set
      optanonConsentCookie &&
      // and functional category is set to be off
      optanonConsentCookie.indexOf('C0002:0') !== -1
    )
  ) {

    // hide body
    //-----------
    // if no one else has created that style yet then create it
    if (!style) {

      // set styles
      style = d.createElement('style');
      style.id = STYLE_ID;
      style.innerHTML = 'body{opacity:0.01 !important}';

      try {
        p.mark('targetBodyHide');
        head.appendChild(style);
      } catch (e) {
        // nothing
      }

    }

    setTimeout(function () {

      // set target flag to disable body hiding. This will make it so that there is
      // no flicker if target doesn't load before 3 seconds
      targetGlobalSettings[bodyHidingEnabledString] = false;

      // unhide body
      //-------------
      // try to remove the style
      try {
        head.removeChild(d.getElementById(STYLE_ID));
      } catch (e) {
        // nothing
      }

    }, 3000);

  } else {

    // if we found the style, remove it
    if (
      style &&
      style.parentNode
    ) {
      style.parentNode.removeChild(style);
    }

  }

  function window_addEventListener (e, fn) {
    w.addEventListener(e, fn);
  }

  function launchContainer (min, hostname) {
    var
      l = w.location,
      h,
      embedCode,
      property,
      environment,

      // TODO: Self-hosting option
      host = 'https://assets.adobedtm.com/',
      container = host + 'launch-',
      // container2 = host + '/d4d114c60e50/fcc2f6143119/launch-',

      // environment types
      dev = 'dev',
      stage = 'stage',
      prod = 'production',

      containerProps = {
        // global embed codes
        'globalDev': 'EN9a7b3bd7db454856b44f27730f263fa0',
        'globalStage': 'EN2731bb0857084837b7142cd2017286bb',
        'globalProd': 'EN919758db9a654a17bac7d184b99c4820',
        // unified checkout embed codes
        'ucDev': 'ENed7cfab651fa4714a57bf937efb0cd23-development',
        'ucStage': 'EN1450794db7d0411a8b3f3b08dd706d00-staging',
        'ucProd': 'ENd6b040128459463bad781a5daa85ce0f',
        // video analytics embed codes
        'videoDev': 'EN2d7bf2d8326b4ff1aa5335189a385023-development',
        'videoStage': 'EN60e5086def0d48e9ae2195234cb1b389-staging',
        'videoProd': 'EN58452fb8d9534cacbb8aeac0c8e15215',
        //minimal embed codes
        'minimalDev': 'EN876eeadff442464cb438819d695e077d-development',
        'minimalStage': 'ENa9d6ac46ca57441784434d28ceb9ddba-staging',
        'minimalProd': 'EN08637acac77f4e20b9e413aeb86f610e'
      },

      invalidEnvironment = function () {
        // eslint-disable-next-line no-console
        console.warn(
          'marketingtech.adobe.launch.environment invalid. ' +
          'Falling back to "production".'
        );
      },

      hostnameContains;

    // parameter or default to location.hostname
    h = hostname || l.hostname;

    // contains function for minification
    hostnameContains = function (string) {
      return h.indexOf(string) !== -1;
    };

    //----------------------------------------------------------------------------
    // Using flags
    //----------------------------------------------------------------------------
    if (
      marketingtech &&
      marketingtech.adobe &&
      marketingtech.adobe.launch &&
      (
        marketingtech.adobe.launch.embedCode ||
        marketingtech.adobe.launch.environment ||
        marketingtech.adobe.launch.property
      )
    ) {

      embedCode = marketingtech.adobe.launch.embedCode;
      property = marketingtech.adobe.launch.property;
      environment = marketingtech.adobe.launch.environment;
      var propSet = function (envV) {
        if (envV == 'video analytics') {
          envV = 'video';
        }
        if (envV == 'unified checkout') {
          envV = 'uc';
        }
        if (environment === dev) {
          container += containerProps[envV + 'Dev'];
        } else if (environment === stage) {
          container += containerProps[envV + 'Stage'];
        } else if (environment === prod) {
          container += containerProps[envV + 'Prod'];
        } else {
          container += containerProps[envV + 'Prod'];

          invalidEnvironment();
        }
      };

      // first check if they are passing the embed code explicitly.  If so, just use that.
      if (embedCode) {

        // if it was the old format
        if (embedCode.indexOf('EN') === 0) {
          container += embedCode;

          // if it is the new format
        } else {
          container = host + embedCode;
        }

        // global container
      } else if (property) {
        propSet(property);
      }
        // unspecified or unrecognized
      // default to global
      else {
        propSet('global');
      }

      //----------------------------------------------------------------------------
      // Account Management Sites - Francisc Romano <romano@adobe.com>
      //----------------------------------------------------------------------------

      // dev
    } else if (
      // local/dev
      hostnameContains('localhost.account.adobe.com') ||
      hostnameContains('prestage1.account.adobe.com') ||
      hostnameContains('prestage2.account.adobe.com')
    ) {
      container += containerProps['globalDev'];

      // stage
    } else if (
      hostnameContains('stage.account.adobe.com') ||
      hostnameContains('prod-inactive.account.adobe.com') ||
      hostnameContains('prod-active.account.adobe.com')
    ) {
      container += containerProps['globalStage'];

      // prod
    } else if (
      hostnameContains('account.adobe.com')
    ) {
      container += containerProps['globalProd'];

      //----------------------------------------------------------------------------
      // local
      //----------------------------------------------------------------------------
    } else if (
      hostnameContains('localhost.')
    ) {
      container += containerProps['globalDev'];

      //----------------------------------------------------------------------------
      // fallback to "global" container and "dev" environment
      //----------------------------------------------------------------------------

    } else {

      // eslint-disable-next-line no-console
      console.error(
        'unrecognized domain. ' +
        'Please email marketingtech@adobe.com.'
      );

      container += containerProps['globalDev'];
    }

    //----------------------------------------------------------------------------
    // Minification
    //----------------------------------------------------------------------------
    if (min) {
      container += '.min';
    }

    // return it
    return container + '.js';
  }

  function loadScript (src, onload) {

    var
      s = d.createElement('script'),
      first,
      parent,
      called = false;

    s.src = src;
    // PATCH
    s.type = 'text/partytown';
    // s.async = true;

    // if there is an onload callback
    if (onload) {

      s.onload = s.onreadystatechange = function (e) {
        var
          readyState = this.readyState;

        if (
          // only call the callback once
          !called &&
          (
            // either readyState doesn't exist
            !readyState ||
            // or it is set to complete or loaded
            (
              readyState === 'complete' ||
              readyState === 'loaded'
            )
          )
        ) {
          called = true;
          onload(e);
        }

      };

    }

    // find the first script
    first = d.getElementsByTagName('script')[0];

    // if we found the first script tag and it has a parentNode, insert the script
    if (
      first &&
      first.parentNode
    ) {
      parent = first.parentNode;
      parent.insertBefore(s, first);

      // if we didn't find it, try inserting into the head
    } else {
      parent = head;

      // if we found the head
      if (parent) {
        parent.appendChild(s);

        // if we didn't find the head, try the body
      } else if (d.body) {
        parent = d.body;
        parent.appendChild(s);

        // otherwise indicate we don't know where we can put this
      } else {
        throwError('no script parent');
      }

    }

  }

  var encode = encodeURIComponent;

//----------------------------------------------------------------------------
// setCookie function
//----------------------------------------------------------------------------
  function setCookie (name, value, config, noEncoding) {
    var
      cookieString = '';

    // default to blank
    value = value || '';

    // determine whether to encode the key value pairs or not
    if (noEncoding) {
      cookieString +=
        name + '=' +
        value;
    } else {
      cookieString +=
        encode(name) + '=' +
        encode(value);
    }

    // path
    if (config.path) {
      cookieString +=
        '; path=' + config.path;
    }

    // expires
    if (config.expires) {
      cookieString +=
        '; expires=' + config.expires.toUTCString();
    }

    // domain
    if (config.domain) {
      cookieString +=
        '; domain=' + config.domain;
    }

    // samesite
    if (config.samesite) {
      cookieString +=
        '; samesite=' + config.samesite;
    }

    d.cookie = cookieString;
  }

  var effectiveDomain = '';

//----------------------------------------------------------------------------
// getDomain function
//----------------------------------------------------------------------------
  function getCookieDomain () {

    if (effectiveDomain) {
      return effectiveDomain;
    }

    var
      parts = w.location.hostname.toLowerCase().split('.'),
      domain = [],
      part = '',
      date = null,
      successfullySet = false,
      name = 'sat_domain',
      value = 'A';

    // we know we can't set on tld, so just skip tld
    part = parts.pop();
    domain.unshift(part);

    while (parts.length > 0) {
      part = parts.pop();

      domain.unshift(part);

      date = new Date();
      date.setTime(date.getTime() + 1000);

      try {
        setCookie(name, value, {
          expires: date,
          domain: domain.join('.')
        });
      } catch (err) {
        break;
      }

      if (readCookie(name) === value) {
        successfullySet = true;
        effectiveDomain = domain.join('.');
        break;
      }
    }

    return successfullySet ? effectiveDomain : '';
  }

  var __satelliteLoadedCallback;
  var __satelliteLoadedPromise;
  var callbacks = [];
  var handleCallbacks;
  var loaded;
  var check;
  var write;
  var adobePrivacyPrivacy = 'adobePrivacy:Privacy';
  var OptanonChoice = 'OptanonChoice';
  var expires = new Date();
  var consentChoiceCookieConfig = {
    domain: getCookieDomain(),
    path: '/',
    samesite: 'Lax',
    expires: (
      // one year from now
      expires.setFullYear(expires.getFullYear() + 1), expires)
  };

//------------------------------------------------------------------------------
// callback for when launch loads
//------------------------------------------------------------------------------
  __satelliteLoadedCallback = function (callback) {

    // if launch has already loaded, immediately call the callback
    if (loaded) {
      callback(w._satellite);
      return;
    }

    callbacks.push(callback);
  };

// Promise
  __satelliteLoadedPromise = new Promise(function (resolve) {
    __satelliteLoadedCallback(resolve);
  });

  handleCallbacks = function () {
    var
      i, il,
      callback;

    // indicate we have loaded
    loaded = true;

    // loop through each of the callbacks and call them
    for (i = 0, il = callbacks.length; i < il; i++) {
      callback = callbacks[i];
      try {
        callback(w._satellite);
      } catch (e) {
        // Nothing
      }
    }
  };

// export
  w.__satelliteLoadedCallback = __satelliteLoadedCallback;
  w.__satelliteLoadedPromise = __satelliteLoadedPromise;

// write a script with document.write
  write = function (src) {
    d.write('<sc' + 'ript src="' + src + '"></sc' + 'ript>');
  };

// set our own cookie
  window_addEventListener(adobePrivacyPrivacy + 'Consent', function () {
    setCookie(OptanonChoice, 1, consentChoiceCookieConfig);
  });
  window_addEventListener(adobePrivacyPrivacy + 'Reject', function () {
    setCookie(OptanonChoice, 2, consentChoiceCookieConfig);
  });
  window_addEventListener(adobePrivacyPrivacy + 'Custom', function () {
    setCookie(OptanonChoice, 3, consentChoiceCookieConfig);
  });

// wait for the event to fire, and re-propagate it for DTM and Launch to handle
  window_addEventListener(adobePrivacyPrivacy + 'Consent', function () {
    var
      evt,
      name = adobePrivacyPrivacy + 'Consent:DTM';

    // create the event
    if (typeof w.CustomEvent === 'function') {
      evt = new CustomEvent(name);
    } else {
      evt = d.createEvent('CustomEvent');
      evt.initCustomEvent(name, false, false, undefined);
    }

    // wait for _satellite to load
    __satelliteLoadedCallback(function () {

      // wait for at least the windowloaded event so we don't trigger the
      // direct call rules (like DOM Ready, page bottom, page top) too early.
      // Remember to fire this even if window load has already occurred (last
      // parameter set to true)

      // if window has already loaded
      if (d.readyState === 'complete') {

        // dispatch from the body because DTM only listens for events on the
        // body element and it's children
        d.body.dispatchEvent(evt);

        // if the window hasn't loaded yet
      } else {

        // wait for window loaded event to fire the event to give our clients time
        // to set data on the data layer
        window_addEventListener('load', function () {

          // dispatch from the body because DTM only listens for events on the
          // body element and it's children
          d.body.dispatchEvent(evt);

        }, true);

      }

    });

  });



//------------------------------------------------------------------------------
// load Adobe DTM
//------------------------------------------------------------------------------
  if (__satelliteEmbedCode) {

    // write the evidon country detection script
    write('//c.evidon.com/geo/country.js');

    // load synchronously
    write(__satelliteEmbedCode);

    // wait for the _satellite.initialized property to be set to true by polling
    check = function () {

      // if it is initialized
      if (
        w._satellite &&
        w._satellite.initialized
      ) {
        handleCallbacks();

        // if it is not initialized yet
      } else {
        setTimeout(check, 100);
      }
    };

    // start polling
    check();

//------------------------------------------------------------------------------
// load Adobe Launch
//------------------------------------------------------------------------------
  } else {

    // load the script
    loadScript(
      // container src
      launchContainer(),
      // onload
      handleCallbacks
    );

  }

  function copyLocation (w) {
    // var loc = JSON.parse(JSON.stringify(w.location));
    // PATCH - for some reason in a webworker, w.location will be stringified as "<url>"
    // and not the full object.
    var loc = w.location;
    loc.href = redact(loc.href);
    loc.hash = redact(loc.hash);
    loc.search = redact(loc.search);
    return loc;
  }

  var pageInfoString = 'initialPage.pageInfo.location';
  var messageString = 'message';
  var pageInfoLocation;
  var top = w.top;

// if I'm the top frame
  if (w === top) {

    // get the initial value
    pageInfoLocation = copyLocation(w);

    // if anyone asks me, tell them what my location is
    window_addEventListener(messageString, function (e) {
      var
        origin = e.origin,
        length = origin.length,
        endsWith;

      // ends with domain
      endsWith = function (domain) {
        return origin.substring(length - domain.length, length) === domain;
      };

      if (
        // if it comes from one of our top level domains, allow it and reply
        (
          endsWith('.adobe.com') ||
          endsWith('//adobe.com')
        ) &&
        // is is the data we are looking for
        e.data.n === pageInfoString
      ) {
        e.source.postMessage({
          n: pageInfoString,
          v: pageInfoLocation
        }, '*');
      }
    });

  }

// export the function
  function setDigitalDataTopFrameLocation (digitalData, path) {

    try {
      digitalData._set(path, copyLocation(top));
    } catch (e) {

      // listen for a return message from the top frame
      window_addEventListener(messageString, function (e) {
        if (
          // it is the data we are looking for
          e.data.n === pageInfoString
        ) {
          digitalData._set(path, e.data.v);
        }
      });

      // tell the top frame I need it's location
      top.postMessage({
        n: pageInfoString
      }, '*');

    }

  }

  var trackCalls = [];

// get _satellite
  w._satellite = w._satellite || {};

// set track function
  w._satellite.track = function (directCallRuleName, detail) {
    var
      snapshot;

    // default it
    detail = detail || {};

    // save a property to indicate this was called before
    detail._beforeSatelliteLoaded = true;

    // only when using launch
    if (!__satelliteEmbedCode) {

      // get a snapshot if I haven't gotten one yet
      snapshot = detail.digitalData = detail.digitalData || w.digitalData._snapshot();

      // digitalData.page.pageInfo.location
      //-----------------------------------
      snapshot._set('page.pageInfo.location', copyLocation(w));

      // digitalData.page.topFrameInfo.location
      //---------------------------------------
      setDigitalDataTopFrameLocation(snapshot, 'page.topFrameInfo.location');

    }

    // push call on stack
    trackCalls.push([directCallRuleName, detail]);

  };

// When _satellite has loaded
  w.__satelliteLoadedCallback(function () {
    var
      i, il,
      params;

    // loop through each of the calls
    for (i = 0, il = trackCalls.length; i < il; i++) {

      // params
      params = trackCalls[i];

      // recall _satellite.track
      w._satellite.track(params[0], params[1]);
    }

  });

  var version = '0.19.0';

// set version
  if (!__satelliteEmbedCode) {

    // marketingtech.bootstrap.version
    //----------------------------------------------------------------------------
    digitalData$1._set('marketingtech.bootstrap.version', version);

    // initialPage.pageInfo.location
    //----------------------------------------------------------------------------
    digitalData$1._set('initialPage.pageInfo.location', copyLocation(w));

    // initialPage.topFrameInfo.location
    //----------------------------------------------------------------------------
    setDigitalDataTopFrameLocation(digitalData$1, 'initialPage.topFrameInfo.location');

  }

// import './main/visitor.js';
// import './main/alloy.js';

}());
